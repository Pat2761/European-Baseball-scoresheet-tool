/*
 * European scorekeeper tool
 * Copyright (C) 2020  Patrick BRIAND
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * generated by Xtext 2.23.0
 * 
 */
package org.bpy.score.game.formatting2

import org.bpy.score.game.game.Actions
import org.bpy.score.game.game.Game
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.bpy.score.game.game.GamePackage
import org.bpy.score.game.game.Description
import org.bpy.score.game.game.ScoreKeepers
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.bpy.score.game.game.Umpires
import org.bpy.score.game.game.Roster
import org.bpy.score.game.game.Player
import org.bpy.score.game.game.LineUp
import org.bpy.score.game.game.LineUpEntry
import org.bpy.score.game.game.HalfInning
import org.bpy.score.game.game.InningSetting
import org.bpy.score.game.game.Action
import org.bpy.score.game.game.SubstitutionEvent
import org.bpy.score.game.game.Commands
import org.bpy.score.game.game.Note
import org.bpy.score.game.game.ForfeitGame
import org.bpy.score.game.game.Pitches
import org.bpy.score.game.game.GameResume

/**
 * Allow to format a game file
 * 
 * @author: Patrick BRIAND
 */
class GameFormatter extends AbstractFormatter2 {

	/**
	 * Format the main entry of the file
	 * 
	 * @param game Game grammar rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Game game, extension IFormattableDocument document) {

		game.regionFor.feature(GamePackage.Literals.GAME__NAME)?.prepend[oneSpace]
		game.regionFor.feature(GamePackage.Literals.GAME__NAME)?.append[oneSpace]
		game.regionFor.keyword("{")?.append[newLines =2; indent]

		val open = game.regionFor.keyword("{")
		val close = game.regionFor.keyword("}")
		if (open !== null && close !== null) {
			interior(open, close)[indent]
			
			game.description?.format

			game.visitor?.format
			game.hometeam?.format

			game.actions?.format
			
			game.forfeitGame?.format			
		}

	}

	/**
	 * Format the forfeit game declaration of the file
	 * 
	 * @param actions forfeitGame rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(ForfeitGame forfeitGame, extension IFormattableDocument document) {
		val forfeitKeyword = forfeitGame.regionFor.keyword('forfeit')
		if (forfeitKeyword !== null) {
			forfeitKeyword.append[oneSpace]
			
			if (forfeitKeyword.nextSemanticRegion !== null) {
				forfeitKeyword.nextSemanticRegion.append[noSpace]
				
				forfeitGame.regionFor.keyword(';')?.append[newLine]
			}
		} 
	}

	/**
	 * Format the Actions part of the file
	 * 
	 * @param actions Actions rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Actions actions, extension IFormattableDocument document) {
		actions.regionFor.keyword('gameEntry')?.prepend[noSpace].append[oneSpace]
		
		val open = actions.regionFor.keyword('{')
		val close = actions.regionFor.keyword('}')
		
		if (open !== null && close !==null) {
			open.append[newLines = 2]
			close.append[newLines = 2]
			interior(open,close)[indent]
			
			for (lineUp : actions.lineup) {
				lineUp.format
			}

			for (halfInning : actions.halfInnings) {
				halfInning.format
			}
			actions.gameResume?.format
		}
	}

	/**
	 * Format the GameResume part of the actions area
	 * 
	 * @param gameResume GameResume rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(GameResume gameResume, extension IFormattableDocument document) {
		gameResume.regionFor.keyword('gameResume')?.prepend[noSpace].append[oneSpace]
		val open = gameResume.regionFor.keyword('{')
		val close = gameResume.regionFor.keyword('}')
		
		if (open !== null && close !== null) {
			open.append[noSpace;newLine]
			close.append[newLine]
			interior(open,close)[indent]
			
			val win = gameResume.regionFor.keyword('win')
			win?.nextSemanticRegion?.surround[oneSpace]
			win?.nextSemanticRegion?.nextSemanticRegion.nextSemanticRegion.prepend[noSpace].append[newLine]

			val lose = gameResume.regionFor.keyword('lose')
			lose?.nextSemanticRegion?.surround[oneSpace]
			lose?.nextSemanticRegion?.nextSemanticRegion.nextSemanticRegion.prepend[noSpace].append[newLine]

			val save = gameResume.regionFor.keyword('save')
			save?.nextSemanticRegion?.surround[oneSpace]
			save?.nextSemanticRegion?.nextSemanticRegion.nextSemanticRegion.prepend[noSpace].append[newLine]
		}
	}

	/**
	 * Format the HalfInning part of the actions area
	 * 
	 * 'inning' team=TeamTypeEnum 'number' number=INT '{'
	 * 
	 * @param halfInning HalfInning rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(HalfInning halfInning, extension IFormattableDocument document) {
		halfInning.regionFor.keyword('inning')?.prepend[noSpace].append[oneSpace]
		halfInning.regionFor.keyword('number')?.surround[oneSpace]
		
		val open = halfInning.regionFor.keyword('{')
		val close = halfInning.regionFor.keyword('}')
		
		if (open !== null && close !==null) {
			
			open.prepend[oneSpace].append[newLine]
			close.prepend[newLine].append[newLines = 2]
			interior(open,close)[indent]
			
			for (inningSetting : halfInning.inningSetting) {
				inningSetting.format
			}
			
			for (inningElement : halfInning.inningElements) {
				inningElement.format
			}
			
			for (note : halfInning.notes) {
				note.format
			}
		}
	}

	/**
	 * Format the the inning setting part of the actions area (tie break situation)
	 * 
	 * specialSituation {
     *    tieBreak
     * }
	 * 
	 * @param inningSetting inningSetting rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(InningSetting  inningSetting, extension IFormattableDocument document) {
		inningSetting.regionFor.keyword('specialSituation')?.append[oneSpace]
		val open = inningSetting.regionFor.keyword('{')
		val close = inningSetting.regionFor.keyword('}')
		
		if (open !== null && close !== null) {
			open.append[noSpace;newLine]
			close.append[newLine]
			interior(open,close)[indent]
			
			inningSetting.regionFor.keyword('tieBreak')?.prepend[noSpace].append[newLine]
		} 
	}

	/**
	 * Format the Action part of the actions area
	 * 
     *	(pitches = Pitches)?
 	 * 'action' '{'
	 *	   (
	 *  		(batterAction   = BatterAction (',' runnerActions+=RunnerAction)* ) |
	 *  	    (runnerActions += RunnerAction (',' runnerActions+=RunnerAction)* )
   	 *     )
	 * '}'
	 * 
	 * @param action Action rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Action action, extension IFormattableDocument document) {
		
		action.pitches.format
		action.regionFor.keyword('action')?.prepend[noSpace].append[oneSpace]
		val open = action.regionFor.keyword('{')
		val close = action.regionFor.keyword('}')
		
		if (open !== null && close !== null) {
			close.append[newLine]
			var currentObject = open
			while (currentObject != close) {
				currentObject.append[oneSpace]
				currentObject = currentObject.nextSemanticRegion
			}
		} 
	}

	/**
	 * Format the Pitches part of the action area
	 * 
	 * @param pitches Pitch rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Pitches pitches, extension IFormattableDocument document) {
		
		var region = pitches.pitches.get(0).regionFor.feature(GamePackage.Literals.PITCH__PITCH)
		
		while (region !== null) {
			val grammarElement = region.grammarElement
			if (Keyword.isInstance(grammarElement)) {
				
				val keyword = grammarElement as Keyword
				
				if (',' == keyword.value) {
					region.append[noSpace]
					region = region.nextSemanticRegion
				} else {
					region = null
				}
			} else {
				
				var endedRegion = false;
				
				val nextRegion = region.nextSemanticRegion
				val nextGrammarElement = nextRegion.grammarElement
				
				if (Keyword.isInstance(nextGrammarElement)) {
					val keyword = nextGrammarElement as Keyword
					if (keyword.value != ',') {
						endedRegion = true;
					}
				}
				
				if (endedRegion) {
					region.append[newLine]
				} else {
					region.append[noSpace]	
				}
				region = region.nextSemanticRegion
			}
		}
	}

	/**
	 * Format the substitution event part of the actions area
	 * 
	 * @param substitutionElement substitution event rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(SubstitutionEvent substitutionElement, extension IFormattableDocument document) {
		substitutionElement.regionFor.keyword('substitution')?.append[oneSpace]
		val open = substitutionElement.regionFor.keyword('{')
		val close = substitutionElement.regionFor.keyword('}')
		
		if (open !== null && close !== null) {
			open.prepend[oneSpace].append[noSpace; newLine]
			close.prepend[noSpace].append[newLine]
			interior(open,close)[indent]
			
			var currentObject = open.nextSemanticRegion
			
			while (currentObject != close) {
				val nextObject = currentObject.nextSemanticRegion
				val nextGrammarElement = nextObject.grammarElement
				val currentGrammarElement = currentObject.grammarElement
				
				if (nextObject == close) {
					currentObject.append[newLine]
					currentObject = close
				} else {
					
					if (Keyword.isInstance(nextGrammarElement)) {
						val keyword = nextGrammarElement as Keyword
						if (keyword.value == "," || nextObject==close) {
							currentObject.append[noSpace]
						} else {
							currentObject.append[oneSpace]
						}	  
					} if (Keyword.isInstance(currentGrammarElement)) {
						val keyword = currentGrammarElement as Keyword
						if (keyword.value == ",") {
							currentObject.append[newLine]
						} else {
							currentObject.append[oneSpace]
						}	  
					}
					
					currentObject = nextObject
				}
			}
			
			for (substitution : substitutionElement.substitutions) {
				substitution.format
			}				
		}
	}

	/**
	 * Format the Commands part of the actions area
	 * 
	 * @param command Commands rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Commands command, extension IFormattableDocument document) {
		val open = command.regionFor.keyword('graphicalCommand')?.prepend[noSpace].append[oneSpace]
		val close = command.regionFor.keyword(';')
		
		if (open !== null && close !== null) {
			close.append[newLine]
			var currentObject = open
			while (currentObject != close) {
				currentObject.append[oneSpace]
				currentObject = currentObject.nextSemanticRegion
			}
		} 
	}

	/**
	 * Format the note part of the actions area
	 * 
	 * @param note Note rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Note note, extension IFormattableDocument document) {
		note.regionFor.keyword('note')?.append[oneSpace]
		val equals = note.regionFor.keyword('=')?.append[oneSpace]
		equals?.nextSemanticRegion.append[noSpace]
		note.regionFor.keyword(';')?.append[newLine]
	}

	/**
	 * Format the Lineup part of the actions area
	 * 
	 * @param lineup Lineup rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(LineUp lineup, extension IFormattableDocument document) {
		lineup.regionFor.keyword('lineup')?.prepend[noSpace].append[oneSpace]
		
		if (lineup !== null) {
			val open = lineup.regionFor.keyword('{')
			val close = lineup.regionFor.keyword('}')
			if (open !== null && close !==null) {
				open.prepend[oneSpace].append[newLine]
				close.prepend[newLine].append[newLines = 2]
				interior(open,close)[indent]	
				for (lineupEntry : lineup.lineUpEntries) {
					lineupEntry.format
				}
			}
		}
	}
	
	/**
	 * Format the LineUpEntry part of the lineup description
	 * 
	 * 	'name' '=' name=STRING 
	 *  'defensivePosition' '=' 
	 *   defensivePosition=LineUPAtDefensivePosition 
	 *   ('shirtNumber' '=' shirtNumber=INT)?  
	 *  ('laterality' '=' laterality=LATERALITY)? ';'
	 * 
	 * @param lineupEntry LineUpEntry rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(LineUpEntry lineupEntry, extension IFormattableDocument document) {
		lineupEntry.regionFor.keyword('name')?.prepend[noSpace].append[oneSpace]
		lineupEntry.regionFor.keyword('=')?.surround[oneSpace]
		
		
		val dp = lineupEntry.regionFor.keyword('defensivePosition')?.surround[oneSpace]
		dp?.nextSemanticRegion?.surround[oneSpace]
		
		val shirtNumber = lineupEntry.regionFor.keyword('shirtNumber')
		shirtNumber?.prepend[oneSpace].append[oneSpace]
		shirtNumber?.nextSemanticRegion?.surround[oneSpace]
		
		val laterality = lineupEntry.regionFor.keyword('laterality')
		laterality?.prepend[oneSpace].append[oneSpace]
		laterality?.nextSemanticRegion?.surround[oneSpace]

		lineupEntry.regionFor.keyword(';')?.prepend[noSpace].append[noSpace; newLine]
	}

	/**
	 * Format the roster part of the game description
	 * 
	 * @param roster Roster rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Roster roster, extension IFormattableDocument document) {
		val rosterElement = roster.regionFor.keyword('roster')
		if (rosterElement !== null) {
			val nextElement = rosterElement.nextSemanticRegion;
			
			if (nextElement !== null) {
				nextElement.surround[oneSpace]
				val open = roster.regionFor.keyword("{")
				val close = roster.regionFor.keyword("}")
				if (open !== null && close !== null) {
					
					open.prepend[oneSpace].append[newLine]
					
					interior(open, close)[indent]
					for (player : roster.players) {
						player.format(document)
					}
					
					var element = open.nextSemanticRegion
					while (element !== close) {
						val grammarElement = element.grammarElement
						if (Keyword.isInstance(grammarElement)) {
							val keyword = grammarElement as Keyword;
							if ("," == keyword.value ) {
								element.prepend[noSpace].append[newLine]
							}
						}
						element = element.nextSemanticRegion
					}
					
					close.prepend[newLine].append[newLines = 2]			 
				}
			}
		}
	}

	/**
	 * Format the player part of the roster description
	 * 
	 * @param roster Player rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Player player, extension IFormattableDocument document) {
		val playerKeyword = player.regionFor.keyword("player").append[oneSpace]
		
		playerKeyword.nextSemanticRegion ?: playerKeyword.nextSemanticRegion.append[noSpace]
	}
	
	/**
	 * Format the Description object
	 * 
	 * @param description Description grammar rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(Description description, extension IFormattableDocument document) {
		description.regionFor.keyword("{")?.append[newLine; indent]

		if (description !== null) {
			val open = description.regionFor.keyword("{")
			val close = description.regionFor.keyword("}")
	
			if (open !== null && close !== null) {
				interior(open, close)[indent]
	
				description.formatSimpleElement('tournament', document)
				description.formatSimpleElement('stadium', document)
				description.formatSimpleElement('place', document)
				description.formatSimpleElement('date', document)
				description.formatSimpleElement('startTime', document)
				description.formatSimpleElement('endTime', document)
				description.formatSimpleElement('duration', document)
				description.formatSimpleElement('category', document)
				description.formatSimpleElement('type', document)
	
				description.scorekeepers?.format
				description.umpires?.format
				close.append[newLines = 2]
			}
		}
	}

	/**
	 * Format the umpires list
	 * 
	 * @param umpires Umpires grammar rule to format
	 * @param document reference to the document
	 */	
	def dispatch void format(Umpires umpires, extension IFormattableDocument document) {
		val element = umpires.regionFor.keyword('umpires')?.append[oneSpace]
		element?.formatOfficials(document)
	}

	/** 
	 * Format the scoreKeeper list
	 * 
	 * @param scoreKeepers Umpires grammar rule to format
	 * @param document reference to the document
	 */
	def dispatch void format(ScoreKeepers scoreKeepers, extension IFormattableDocument document) {
		val element = scoreKeepers.regionFor.keyword('scorekeepers')?.append[oneSpace]
		element?.formatOfficials(document)
	}

	/**
	 * Format the official list
	 * officals = oneSpace 'name' noSpace, oneSpace 'name' noSpace ';' newLine
	 * 
	 * @param region Semantic region to format
	 * @param document reference to the document
	 * 
	 */
	def formatOfficials(ISemanticRegion region, extension IFormattableDocument document) {
		val equalsRegion = region.nextSemanticRegion?.surround[oneSpace];
		if (equalsRegion !== null) {
	
			var semanticRegion = equalsRegion.nextSemanticRegion;
			if (semanticRegion !== null) {
				while (semanticRegion !== null) {
					val value = semanticRegion.grammarElement
					if (Keyword.isInstance(value)) {
						val keyword = value as Keyword
						if (";" == keyword.value) {
							semanticRegion.append[newLine]
							semanticRegion = null
						} else {
							semanticRegion.append[oneSpace]
							semanticRegion = semanticRegion.nextSemanticRegion
						}
					} else if (RuleCall.isInstance(value)) {
						semanticRegion.append[noSpace]
						semanticRegion = semanticRegion.nextSemanticRegion
					}
				
				}
			}
		}
	}

	/**
	 * Format a common description element 
	 * 
	 * @param description Description element
	 * @param keyword String which represents the element in the description
	 * @param document reference to the document
	 */
	def void formatSimpleElement(Description description, String keyword, extension IFormattableDocument document) {
		val element = description.regionFor.keyword(keyword)?.append[oneSpace]
		val equalsRegion = element?.nextSemanticRegion?.surround[oneSpace]
		val stringRegion = equalsRegion?.nextSemanticRegion
		stringRegion?.prepend[oneSpace].append[noSpace]
		stringRegion?.nextSemanticRegion?.append[newLine]
	}
}
