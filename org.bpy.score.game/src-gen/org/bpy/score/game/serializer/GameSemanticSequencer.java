/*
 * generated by Xtext 2.28.0
 */
package org.bpy.score.game.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.bpy.score.game.game.Actions;
import org.bpy.score.game.game.BatterAdvanceOnBaseOnBall;
import org.bpy.score.game.game.BatterAdvanceOnCatcherInterference;
import org.bpy.score.game.game.BatterAdvanceOnDefensiveChoice;
import org.bpy.score.game.game.BatterAdvanceOnDoubleHit;
import org.bpy.score.game.game.BatterAdvanceOnFlyError;
import org.bpy.score.game.game.BatterAdvanceOnGdpWithError;
import org.bpy.score.game.game.BatterAdvanceOnGdpWithFielderChoice;
import org.bpy.score.game.game.BatterAdvanceOnHitByPitch;
import org.bpy.score.game.game.BatterAdvanceOnHomeRun;
import org.bpy.score.game.game.BatterAdvanceOnIndiference;
import org.bpy.score.game.game.BatterAdvanceOnInsidePark;
import org.bpy.score.game.game.BatterAdvanceOnIntentionalBaseOnBall;
import org.bpy.score.game.game.BatterAdvanceOnKAbr;
import org.bpy.score.game.game.BatterAdvanceOnKPassBall;
import org.bpy.score.game.game.BatterAdvanceOnKWildPitch;
import org.bpy.score.game.game.BatterAdvanceOnKWithError;
import org.bpy.score.game.game.BatterAdvanceOnKWithFielderChoice;
import org.bpy.score.game.game.BatterAdvanceOnObstruction;
import org.bpy.score.game.game.BatterAdvanceOnOccupedBall;
import org.bpy.score.game.game.BatterAdvanceOnReceiveError;
import org.bpy.score.game.game.BatterAdvanceOnSacrificeFlyWithError;
import org.bpy.score.game.game.BatterAdvanceOnSacrificeFlyWithFielderChoice;
import org.bpy.score.game.game.BatterAdvanceOnSacrificeHitWithError;
import org.bpy.score.game.game.BatterAdvanceOnSacrificeHitWithFielderChoice;
import org.bpy.score.game.game.BatterAdvanceOnSingleHit;
import org.bpy.score.game.game.BatterAdvanceOnThrowError;
import org.bpy.score.game.game.BatterAdvanceOnTripleHit;
import org.bpy.score.game.game.BatterBalk;
import org.bpy.score.game.game.BatterLostTurn;
import org.bpy.score.game.game.BatterMustOutOnFlyFoulBall;
import org.bpy.score.game.game.BatterOutByRule;
import org.bpy.score.game.game.BatterOutOnAppeal;
import org.bpy.score.game.game.BatterOutOnFlyed;
import org.bpy.score.game.game.BatterOutOnFlyedFallBall;
import org.bpy.score.game.game.BatterOutOnGroundedBall;
import org.bpy.score.game.game.BatterOutOnGroundedDoublePlay;
import org.bpy.score.game.game.BatterOutOnInfieldFly;
import org.bpy.score.game.game.BatterOutOnLine;
import org.bpy.score.game.game.BatterOutOnLineDriveFallBall;
import org.bpy.score.game.game.BatterOutOnLookedStrike;
import org.bpy.score.game.game.BatterOutOnPopped;
import org.bpy.score.game.game.BatterOutOnPoppedFallBall;
import org.bpy.score.game.game.BatterOutOnReleasedStrike;
import org.bpy.score.game.game.BatterOutOnSacrificeFly;
import org.bpy.score.game.game.BatterOutOnSacrificeFlyFallBall;
import org.bpy.score.game.game.BatterOutOnSacrificeHit;
import org.bpy.score.game.game.BatterOutOnSwingedStrike;
import org.bpy.score.game.game.Commands;
import org.bpy.score.game.game.CurrentBatter;
import org.bpy.score.game.game.CurrentRunner;
import org.bpy.score.game.game.Description;
import org.bpy.score.game.game.ForfeitGame;
import org.bpy.score.game.game.Game;
import org.bpy.score.game.game.GamePackage;
import org.bpy.score.game.game.GameResume;
import org.bpy.score.game.game.HalfInning;
import org.bpy.score.game.game.InningSetting;
import org.bpy.score.game.game.LineUp;
import org.bpy.score.game.game.LineUpEntry;
import org.bpy.score.game.game.MoveCommand;
import org.bpy.score.game.game.NewDefensivePosition;
import org.bpy.score.game.game.Note;
import org.bpy.score.game.game.Notes;
import org.bpy.score.game.game.Pitch;
import org.bpy.score.game.game.Pitches;
import org.bpy.score.game.game.Player;
import org.bpy.score.game.game.Replacement;
import org.bpy.score.game.game.Roster;
import org.bpy.score.game.game.RunnerAdvanceByBatterAction;
import org.bpy.score.game.game.RunnerAdvanceOnBalk;
import org.bpy.score.game.game.RunnerAdvanceOnCaughtStealingWithError;
import org.bpy.score.game.game.RunnerAdvanceOnDecisiveObstruction;
import org.bpy.score.game.game.RunnerAdvanceOnDefensiveChoice;
import org.bpy.score.game.game.RunnerAdvanceOnError;
import org.bpy.score.game.game.RunnerAdvanceOnFielderChoice;
import org.bpy.score.game.game.RunnerAdvanceOnIndiference;
import org.bpy.score.game.game.RunnerAdvanceOnNoDecisiveObstruction;
import org.bpy.score.game.game.RunnerAdvanceOnNonDecisiveFlyError;
import org.bpy.score.game.game.RunnerAdvanceOnNonDecisiveReceiveError;
import org.bpy.score.game.game.RunnerAdvanceOnNonDecisiveThrowError;
import org.bpy.score.game.game.RunnerAdvanceOnOccupedBall;
import org.bpy.score.game.game.RunnerAdvanceOnOtherPlayerError;
import org.bpy.score.game.game.RunnerAdvanceOnPassBall;
import org.bpy.score.game.game.RunnerAdvanceOnPickOffWithError;
import org.bpy.score.game.game.RunnerAdvanceOnReceiveError;
import org.bpy.score.game.game.RunnerAdvanceOnRule;
import org.bpy.score.game.game.RunnerAdvanceOnStolenBase;
import org.bpy.score.game.game.RunnerAdvanceOnThrow;
import org.bpy.score.game.game.RunnerAdvanceOnThrowError;
import org.bpy.score.game.game.RunnerAdvanceOnWildPitch;
import org.bpy.score.game.game.RunnerDontAdvanceOnCaughtStealingWithError;
import org.bpy.score.game.game.RunnerDontAdvanceOnError;
import org.bpy.score.game.game.RunnerDontAdvanceOnNonDecisiveReceiveError;
import org.bpy.score.game.game.RunnerDontAdvanceOnNonDecisiveThrowError;
import org.bpy.score.game.game.RunnerDontAdvanceOnPickOffWithError;
import org.bpy.score.game.game.RunnerDontAdvanceOnReceiveError;
import org.bpy.score.game.game.RunnerDontAdvanceOnThrowError;
import org.bpy.score.game.game.RunnerMustBeOutOnError;
import org.bpy.score.game.game.RunnerOutByRules;
import org.bpy.score.game.game.RunnerOutOnAppeal;
import org.bpy.score.game.game.RunnerOutOnCaugthStealing;
import org.bpy.score.game.game.RunnerOutOnFielderAction;
import org.bpy.score.game.game.RunnerOutOnPickOff;
import org.bpy.score.game.game.ScoreKeepers;
import org.bpy.score.game.game.SelectedBatterCommand;
import org.bpy.score.game.game.SubstitutionDescription;
import org.bpy.score.game.game.SubstitutionEvent;
import org.bpy.score.game.game.Umpires;
import org.bpy.score.game.services.GameGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GameSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GameGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GamePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GamePackage.ACTION:
				sequence_Action(context, (org.bpy.score.game.game.Action) semanticObject); 
				return; 
			case GamePackage.ACTIONS:
				sequence_Actions(context, (Actions) semanticObject); 
				return; 
			case GamePackage.BATTER_ADVANCE_ON_BASE_ON_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnBaseOnBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnBaseOnBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_CATCHER_INTERFERENCE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnCatcherInterference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnCatcherInterference) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_DEFENSIVE_CHOICE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_DefensiveChoiceForBatter(context, (BatterAdvanceOnDefensiveChoice) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefensiveChoiceForBatterRule()) {
					sequence_DefensiveChoiceForBatter(context, (BatterAdvanceOnDefensiveChoice) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_DOUBLE_HIT:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_Hit(context, (BatterAdvanceOnDoubleHit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getHitRule()) {
					sequence_Hit(context, (BatterAdvanceOnDoubleHit) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_FLY_ERROR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_DecisiveError(context, (BatterAdvanceOnFlyError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDecisiveErrorRule()) {
					sequence_DecisiveError(context, (BatterAdvanceOnFlyError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_GDP_WITH_ERROR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_DecisiveError(context, (BatterAdvanceOnGdpWithError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDecisiveErrorRule()) {
					sequence_DecisiveError(context, (BatterAdvanceOnGdpWithError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_GDP_WITH_FIELDER_CHOICE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnGdpWithFielderChoice) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnGdpWithFielderChoice) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_HIT_BY_PITCH:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnHitByPitch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnHitByPitch) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_HOME_RUN:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_Hit(context, (BatterAdvanceOnHomeRun) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getHitRule()) {
					sequence_Hit(context, (BatterAdvanceOnHomeRun) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_INDIFERENCE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_DefensiveChoiceForBatter(context, (BatterAdvanceOnIndiference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefensiveChoiceForBatterRule()) {
					sequence_DefensiveChoiceForBatter(context, (BatterAdvanceOnIndiference) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_INSIDE_PARK:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_Hit(context, (BatterAdvanceOnInsidePark) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getHitRule()) {
					sequence_Hit(context, (BatterAdvanceOnInsidePark) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_INTENTIONAL_BASE_ON_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnIntentionalBaseOnBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnIntentionalBaseOnBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_KABR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnKAbr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnKAbr) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_KPASS_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnKPassBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnKPassBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_KWILD_PITCH:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnKWildPitch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnKWildPitch) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_KWITH_ERROR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnKWithError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnKWithError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_KWITH_FIELDER_CHOICE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnKWithFielderChoice) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnKWithFielderChoice) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_OBSTRUCTION:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnObstruction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnObstruction) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_OCCUPED_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_DefensiveChoiceForBatter(context, (BatterAdvanceOnOccupedBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefensiveChoiceForBatterRule()) {
					sequence_DefensiveChoiceForBatter(context, (BatterAdvanceOnOccupedBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_RECEIVE_ERROR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_DecisiveError(context, (BatterAdvanceOnReceiveError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDecisiveErrorRule()) {
					sequence_DecisiveError(context, (BatterAdvanceOnReceiveError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_SACRIFICE_FLY_WITH_ERROR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeFlyWithError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeFlyWithError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_SACRIFICE_FLY_WITH_FIELDER_CHOICE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeFlyWithFielderChoice) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeFlyWithFielderChoice) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_SACRIFICE_HIT_WITH_ERROR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeHitWithError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeHitWithError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_SACRIFICE_HIT_WITH_FIELDER_CHOICE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeHitWithFielderChoice) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherBatterAdvanceRule()) {
					sequence_OtherBatterAdvance(context, (BatterAdvanceOnSacrificeHitWithFielderChoice) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_SINGLE_HIT:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_Hit(context, (BatterAdvanceOnSingleHit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getHitRule()) {
					sequence_Hit(context, (BatterAdvanceOnSingleHit) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_THROW_ERROR:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_DecisiveError(context, (BatterAdvanceOnThrowError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDecisiveErrorRule()) {
					sequence_DecisiveError(context, (BatterAdvanceOnThrowError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_ADVANCE_ON_TRIPLE_HIT:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterAdvanceRule()) {
					sequence_BatterAdvance_Hit(context, (BatterAdvanceOnTripleHit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getHitRule()) {
					sequence_Hit(context, (BatterAdvanceOnTripleHit) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_BALK:
				sequence_BatterBalk(context, (BatterBalk) semanticObject); 
				return; 
			case GamePackage.BATTER_LOST_TURN:
				sequence_BatterLostTurn(context, (BatterLostTurn) semanticObject); 
				return; 
			case GamePackage.BATTER_MUST_OUT_ON_FLY_FOUL_BALL:
				sequence_BatterMustOutOnFlyFoulBall(context, (BatterMustOutOnFlyFoulBall) semanticObject); 
				return; 
			case GamePackage.BATTER_OUT_BY_RULE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutByRule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutByRule) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_APPEAL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnAppeal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnAppeal) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_FLYED:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnFlyed) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnFlyed) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_FLYED_FALL_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnFlyedFallBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnFlyedFallBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_GROUNDED_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnGroundedBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnGroundedBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_GROUNDED_DOUBLE_PLAY:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnGroundedDoublePlay) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnGroundedDoublePlay) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_INFIELD_FLY:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnInfieldFly) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnInfieldFly) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_LINE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnLine) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnLine) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_LINE_DRIVE_FALL_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnLineDriveFallBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnLineDriveFallBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_LOOKED_STRIKE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_StrikeOut(context, (BatterOutOnLookedStrike) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStrikeOutRule()) {
					sequence_StrikeOut(context, (BatterOutOnLookedStrike) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_POPPED:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnPopped) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnPopped) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_POPPED_FALL_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnPoppedFallBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnPoppedFallBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_RELEASED_STRIKE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_StrikeOut(context, (BatterOutOnReleasedStrike) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStrikeOutRule()) {
					sequence_StrikeOut(context, (BatterOutOnReleasedStrike) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_SACRIFICE_FLY:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnSacrificeFly) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnSacrificeFly) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_SACRIFICE_FLY_FALL_BALL:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnSacrificeFlyFallBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnSacrificeFlyFallBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_SACRIFICE_HIT:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_FielderOut(context, (BatterOutOnSacrificeHit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFielderOutRule()) {
					sequence_FielderOut(context, (BatterOutOnSacrificeHit) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.BATTER_OUT_ON_SWINGED_STRIKE:
				if (rule == grammarAccess.getBatterActionRule()
						|| rule == grammarAccess.getBatterOutRule()) {
					sequence_BatterOut_StrikeOut(context, (BatterOutOnSwingedStrike) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStrikeOutRule()) {
					sequence_StrikeOut(context, (BatterOutOnSwingedStrike) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.COMMANDS:
				sequence_Commands(context, (Commands) semanticObject); 
				return; 
			case GamePackage.CURRENT_BATTER:
				sequence_CurrentBatter(context, (CurrentBatter) semanticObject); 
				return; 
			case GamePackage.CURRENT_RUNNER:
				sequence_CurrentRunner(context, (CurrentRunner) semanticObject); 
				return; 
			case GamePackage.DESCRIPTION:
				sequence_Description(context, (Description) semanticObject); 
				return; 
			case GamePackage.FORFEIT_GAME:
				sequence_ForfeitGame(context, (ForfeitGame) semanticObject); 
				return; 
			case GamePackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case GamePackage.GAME_RESUME:
				sequence_GameResume(context, (GameResume) semanticObject); 
				return; 
			case GamePackage.HALF_INNING:
				sequence_HalfInning(context, (HalfInning) semanticObject); 
				return; 
			case GamePackage.INNING_SETTING:
				sequence_InningSetting(context, (InningSetting) semanticObject); 
				return; 
			case GamePackage.LINE_UP:
				sequence_LineUp(context, (LineUp) semanticObject); 
				return; 
			case GamePackage.LINE_UP_ENTRY:
				sequence_LineUpEntry(context, (LineUpEntry) semanticObject); 
				return; 
			case GamePackage.MOVE_COMMAND:
				sequence_MoveCommand(context, (MoveCommand) semanticObject); 
				return; 
			case GamePackage.NEW_DEFENSIVE_POSITION:
				sequence_NewDefensivePosition(context, (NewDefensivePosition) semanticObject); 
				return; 
			case GamePackage.NOTE:
				sequence_Note(context, (Note) semanticObject); 
				return; 
			case GamePackage.NOTES:
				sequence_Notes(context, (Notes) semanticObject); 
				return; 
			case GamePackage.PITCH:
				sequence_Pitch(context, (Pitch) semanticObject); 
				return; 
			case GamePackage.PITCHES:
				sequence_Pitches(context, (Pitches) semanticObject); 
				return; 
			case GamePackage.PLAYER:
				sequence_Player(context, (Player) semanticObject); 
				return; 
			case GamePackage.REPLACEMENT:
				sequence_Replacement(context, (Replacement) semanticObject); 
				return; 
			case GamePackage.ROSTER:
				sequence_Roster(context, (Roster) semanticObject); 
				return; 
			case GamePackage.RUNNER_ADVANCE_BY_BATTER_ACTION:
				if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceByBatterAction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceByBatterAction) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_BALK:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnBalk) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnBalk) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnBalk) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_CAUGHT_STEALING_WITH_ERROR:
				if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnCaughtStealingWithError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnCaughtStealingWithError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_DECISIVE_OBSTRUCTION:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnDecisiveObstruction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnDecisiveObstruction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnDecisiveObstruction) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_DEFENSIVE_CHOICE:
				sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnDefensiveChoice) semanticObject); 
				return; 
			case GamePackage.RUNNER_ADVANCE_ON_ERROR:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_FIELDER_CHOICE:
				if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnFielderChoice) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnFielderChoice) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_INDIFERENCE:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnIndiference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnIndiference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnIndiference) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_NO_DECISIVE_OBSTRUCTION:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnNoDecisiveObstruction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnNoDecisiveObstruction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnNoDecisiveObstruction) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_NON_DECISIVE_FLY_ERROR:
				sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnNonDecisiveFlyError) semanticObject); 
				return; 
			case GamePackage.RUNNER_ADVANCE_ON_NON_DECISIVE_RECEIVE_ERROR:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnNonDecisiveReceiveError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnNonDecisiveReceiveError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnNonDecisiveReceiveError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_NON_DECISIVE_THROW_ERROR:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnNonDecisiveThrowError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnNonDecisiveThrowError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnNonDecisiveThrowError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_OCCUPED_BALL:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnOccupedBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnOccupedBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnOccupedBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_OTHER_PLAYER_ERROR:
				if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnOtherPlayerError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnOtherPlayerError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_PASS_BALL:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnPassBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnPassBall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnPassBall) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_PICK_OFF_WITH_ERROR:
				if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnPickOffWithError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnPickOffWithError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_RECEIVE_ERROR:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnReceiveError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnReceiveError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnReceiveError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_RULE:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnRule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnRule) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnRule) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_STOLEN_BASE:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnStolenBase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnStolenBase) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnStolenBase) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_THROW:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnThrow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnThrow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnThrow) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_THROW_ERROR:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnThrowError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnThrowError) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnThrowError) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_ADVANCE_ON_WILD_PITCH:
				if (rule == grammarAccess.getAdvanceWithContinuationRule()) {
					sequence_AdvanceWithContinuation(context, (RunnerAdvanceOnWildPitch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()) {
					sequence_RunnerAction_RunnerAdvance(context, (RunnerAdvanceOnWildPitch) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerAdvanceRule()) {
					sequence_RunnerAdvance(context, (RunnerAdvanceOnWildPitch) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_DONT_ADVANCE_ON_CAUGHT_STEALING_WITH_ERROR:
				sequence_OtherRunnerAction(context, (RunnerDontAdvanceOnCaughtStealingWithError) semanticObject); 
				return; 
			case GamePackage.RUNNER_DONT_ADVANCE_ON_ERROR:
				sequence_OtherRunnerAction(context, (RunnerDontAdvanceOnError) semanticObject); 
				return; 
			case GamePackage.RUNNER_DONT_ADVANCE_ON_NON_DECISIVE_RECEIVE_ERROR:
				sequence_OtherRunnerAction(context, (RunnerDontAdvanceOnNonDecisiveReceiveError) semanticObject); 
				return; 
			case GamePackage.RUNNER_DONT_ADVANCE_ON_NON_DECISIVE_THROW_ERROR:
				sequence_OtherRunnerAction(context, (RunnerDontAdvanceOnNonDecisiveThrowError) semanticObject); 
				return; 
			case GamePackage.RUNNER_DONT_ADVANCE_ON_PICK_OFF_WITH_ERROR:
				sequence_OtherRunnerAction(context, (RunnerDontAdvanceOnPickOffWithError) semanticObject); 
				return; 
			case GamePackage.RUNNER_DONT_ADVANCE_ON_RECEIVE_ERROR:
				sequence_OtherRunnerAction(context, (RunnerDontAdvanceOnReceiveError) semanticObject); 
				return; 
			case GamePackage.RUNNER_DONT_ADVANCE_ON_THROW_ERROR:
				sequence_OtherRunnerAction(context, (RunnerDontAdvanceOnThrowError) semanticObject); 
				return; 
			case GamePackage.RUNNER_MUST_BE_OUT_ON_ERROR:
				sequence_OtherRunnerAction(context, (RunnerMustBeOutOnError) semanticObject); 
				return; 
			case GamePackage.RUNNER_OUT_BY_RULES:
				if (rule == grammarAccess.getMoreAdanceFailRule()) {
					sequence_MoreAdanceFail(context, (RunnerOutByRules) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()
						|| rule == grammarAccess.getRunnerOutRule()) {
					sequence_RunnerOut(context, (RunnerOutByRules) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_OUT_ON_APPEAL:
				if (rule == grammarAccess.getMoreAdanceFailRule()) {
					sequence_MoreAdanceFail(context, (RunnerOutOnAppeal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()
						|| rule == grammarAccess.getRunnerOutRule()) {
					sequence_RunnerOut(context, (RunnerOutOnAppeal) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_OUT_ON_CAUGTH_STEALING:
				sequence_RunnerOut(context, (RunnerOutOnCaugthStealing) semanticObject); 
				return; 
			case GamePackage.RUNNER_OUT_ON_FIELDER_ACTION:
				if (rule == grammarAccess.getMoreAdanceFailRule()) {
					sequence_MoreAdanceFail(context, (RunnerOutOnFielderAction) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRunnerActionRule()
						|| rule == grammarAccess.getRunnerOutRule()) {
					sequence_RunnerOut(context, (RunnerOutOnFielderAction) semanticObject); 
					return; 
				}
				else break;
			case GamePackage.RUNNER_OUT_ON_PICK_OFF:
				sequence_RunnerOut(context, (RunnerOutOnPickOff) semanticObject); 
				return; 
			case GamePackage.SCORE_KEEPERS:
				sequence_ScoreKeepers(context, (ScoreKeepers) semanticObject); 
				return; 
			case GamePackage.SELECTED_BATTER_COMMAND:
				sequence_SelectedBatterCommand(context, (SelectedBatterCommand) semanticObject); 
				return; 
			case GamePackage.SUBSTITUTION_DESCRIPTION:
				sequence_SubstitutionDescription(context, (SubstitutionDescription) semanticObject); 
				return; 
			case GamePackage.SUBSTITUTION_EVENT:
				sequence_SubstitutionEvent(context, (SubstitutionEvent) semanticObject); 
				return; 
			case GamePackage.UMPIRES:
				sequence_Umpires(context, (Umpires) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (pitches=Pitches? ((batterAction=BatterAction runnerActions+=RunnerAction*) | (runnerActions+=RunnerAction runnerActions+=RunnerAction*)))
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, org.bpy.score.game.game.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actions returns Actions
	 *
	 * Constraint:
	 *     (lineup+=LineUp+ halfInnings+=HalfInning* gameResume=GameResume?)
	 * </pre>
	 */
	protected void sequence_Actions(ISerializationContext context, Actions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnBalk
	 *
	 * Constraint:
	 *     (runnerAdvance=BALK (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnBalk semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnDecisiveObstruction
	 *
	 * Constraint:
	 *     (runnerAdvance=DECISIVE_OBSTRUCTION (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnDecisiveObstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnDefensiveChoice
	 *
	 * Constraint:
	 *     (runnerAdvance=FIELDER_CHOICE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnDefensiveChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnError
	 *
	 * Constraint:
	 *     (runnerAdvance=ADVANCE_ON_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnIndiference
	 *
	 * Constraint:
	 *     (runnerAdvance=INDIFERENCE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnIndiference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnNoDecisiveObstruction
	 *
	 * Constraint:
	 *     (runnerAdvance=NO_DECISIVE_OBSTRUCTION (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnNoDecisiveObstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnNonDecisiveFlyError
	 *
	 * Constraint:
	 *     (runnerAdvance=EXTRA_ON_FLY_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnNonDecisiveFlyError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnNonDecisiveReceiveError
	 *
	 * Constraint:
	 *     (runnerAdvance=EXTRA_ON_RECEIVE_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnNonDecisiveReceiveError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnNonDecisiveThrowError
	 *
	 * Constraint:
	 *     (runnerAdvance=EXTRA_ON_THROW_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnNonDecisiveThrowError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnOccupedBall
	 *
	 * Constraint:
	 *     (runnerAdvance=FIELDER_CHOICE_WITH_PUTOUT (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnOccupedBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnPassBall
	 *
	 * Constraint:
	 *     (runnerAdvance=PASS_BALL (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnPassBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnReceiveError
	 *
	 * Constraint:
	 *     (runnerAdvance=REACH_ON_RECEIVE_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnReceiveError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnRule
	 *
	 * Constraint:
	 *     (runnerAdvance=ADVANCE_BY_RULE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnStolenBase
	 *
	 * Constraint:
	 *     (runnerAdvance=STOLEN_BASE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnStolenBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnThrow
	 *
	 * Constraint:
	 *     (runnerAdvance=ADVANCE_ON_THROW (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnThrow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnThrowError
	 *
	 * Constraint:
	 *     (runnerAdvance=REACH_ON_THROW_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnThrowError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvanceWithContinuation returns RunnerAdvanceOnWildPitch
	 *
	 * Constraint:
	 *     (runnerAdvance=WILD_PITCH (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_AdvanceWithContinuation(ISerializationContext context, RunnerAdvanceOnWildPitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnFlyError
	 *     BatterAdvance returns BatterAdvanceOnFlyError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=REACH_ON_FLY_ERROR moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_DecisiveError(ISerializationContext context, BatterAdvanceOnFlyError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnGdpWithError
	 *     BatterAdvance returns BatterAdvanceOnGdpWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=GROUNDED_DOUBLE_PLAY_ADVANCE_WITH_ERROR moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_DecisiveError(ISerializationContext context, BatterAdvanceOnGdpWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnReceiveError
	 *     BatterAdvance returns BatterAdvanceOnReceiveError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=REACH_ON_RECEIVE_ERROR moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_DecisiveError(ISerializationContext context, BatterAdvanceOnReceiveError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnThrowError
	 *     BatterAdvance returns BatterAdvanceOnThrowError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=REACH_ON_THROW_ERROR moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_DecisiveError(ISerializationContext context, BatterAdvanceOnThrowError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnDefensiveChoice
	 *     BatterAdvance returns BatterAdvanceOnDefensiveChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=FIELDER_CHOICE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_DefensiveChoiceForBatter(ISerializationContext context, BatterAdvanceOnDefensiveChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnIndiference
	 *     BatterAdvance returns BatterAdvanceOnIndiference
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=INDIFERENCE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_DefensiveChoiceForBatter(ISerializationContext context, BatterAdvanceOnIndiference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnOccupedBall
	 *     BatterAdvance returns BatterAdvanceOnOccupedBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=FIELDER_CHOICE_WITH_PUTOUT moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_DefensiveChoiceForBatter(ISerializationContext context, BatterAdvanceOnOccupedBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnDoubleHit
	 *     BatterAdvance returns BatterAdvanceOnDoubleHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=DOUBLE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_Hit(ISerializationContext context, BatterAdvanceOnDoubleHit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnHomeRun
	 *     BatterAdvance returns BatterAdvanceOnHomeRun
	 *
	 * Constraint:
	 *     (
	 *         currentBatter=CurrentBatter 
	 *         hit=HOMERUN 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         out=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_BatterAdvance_Hit(ISerializationContext context, BatterAdvanceOnHomeRun semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnInsidePark
	 *     BatterAdvance returns BatterAdvanceOnInsidePark
	 *
	 * Constraint:
	 *     (
	 *         currentBatter=CurrentBatter 
	 *         hit=INSIDE_PARK 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         out=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_BatterAdvance_Hit(ISerializationContext context, BatterAdvanceOnInsidePark semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnSingleHit
	 *     BatterAdvance returns BatterAdvanceOnSingleHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=SINGLE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_Hit(ISerializationContext context, BatterAdvanceOnSingleHit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnTripleHit
	 *     BatterAdvance returns BatterAdvanceOnTripleHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=TRIPLE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_Hit(ISerializationContext context, BatterAdvanceOnTripleHit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnBaseOnBall
	 *     BatterAdvance returns BatterAdvanceOnBaseOnBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=BASE_ON_BALL moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnBaseOnBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnCatcherInterference
	 *     BatterAdvance returns BatterAdvanceOnCatcherInterference
	 *
	 * Constraint:
	 *     (
	 *         currentBatter=CurrentBatter 
	 *         (batterAdvance=CATCHER_INTERFERENCE | batterAdvance=INTERFERENCE) 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         out=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnCatcherInterference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnGdpWithFielderChoice
	 *     BatterAdvance returns BatterAdvanceOnGdpWithFielderChoice
	 *
	 * Constraint:
	 *     (
	 *         currentBatter=CurrentBatter 
	 *         batterAdvance=GROUNDED_DOUBLE_PLAY_ADVANCE_WITH_FIELDER_CHOICE 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         out=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnGdpWithFielderChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnHitByPitch
	 *     BatterAdvance returns BatterAdvanceOnHitByPitch
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=HIT_BY_PITCH moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnHitByPitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnIntentionalBaseOnBall
	 *     BatterAdvance returns BatterAdvanceOnIntentionalBaseOnBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=INTENTIONAL_BASE_ON_BALL moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnIntentionalBaseOnBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnKAbr
	 *     BatterAdvance returns BatterAdvanceOnKAbr
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_ADVANCE_BY_RULE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKAbr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnKPassBall
	 *     BatterAdvance returns BatterAdvanceOnKPassBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_PASS_BALL moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKPassBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnKWildPitch
	 *     BatterAdvance returns BatterAdvanceOnKWildPitch
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_WILD_PITCH moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKWildPitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnKWithError
	 *     BatterAdvance returns BatterAdvanceOnKWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_WITH_ERROR moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnKWithFielderChoice
	 *     BatterAdvance returns BatterAdvanceOnKWithFielderChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_ADVANCE_BY_FIELDER_CHOCE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKWithFielderChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnObstruction
	 *     BatterAdvance returns BatterAdvanceOnObstruction
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=DECISIVE_OBSTRUCTION moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnObstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnSacrificeFlyWithError
	 *     BatterAdvance returns BatterAdvanceOnSacrificeFlyWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_FLY_WITH_ERROR moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeFlyWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnSacrificeFlyWithFielderChoice
	 *     BatterAdvance returns BatterAdvanceOnSacrificeFlyWithFielderChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_FLY_WITH_FIELDER_CHOICE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeFlyWithFielderChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnSacrificeHitWithError
	 *     BatterAdvance returns BatterAdvanceOnSacrificeHitWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_BUNT_WITH_ERROR moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeHitWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterAdvanceOnSacrificeHitWithFielderChoice
	 *     BatterAdvance returns BatterAdvanceOnSacrificeHitWithFielderChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_BUNT_WITH_FIELDER_CHOICE moreAdvances+=AdvanceWithContinuation* out=MoreAdanceFail?)
	 * </pre>
	 */
	protected void sequence_BatterAdvance_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeHitWithFielderChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterBalk
	 *     BatterBalk returns BatterBalk
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAction=BALK)
	 * </pre>
	 */
	protected void sequence_BatterBalk(ISerializationContext context, BatterBalk semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_BALK__BATTER_ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_BALK__BATTER_ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBatterBalkAccess().getCurrentBatterCurrentBatterParserRuleCall_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getBatterBalkAccess().getBatterActionBALKTerminalRuleCall_3_0(), semanticObject.getBatterAction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterLostTurn
	 *     BatterLostTurn returns BatterLostTurn
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=LOST_TURN)
	 * </pre>
	 */
	protected void sequence_BatterLostTurn(ISerializationContext context, BatterLostTurn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_LOST_TURN__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_LOST_TURN__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBatterLostTurnAccess().getCurrentBatterCurrentBatterParserRuleCall_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getBatterLostTurnAccess().getBatterAdvanceLOST_TURNTerminalRuleCall_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterMustOutOnFlyFoulBall
	 *     BatterMustOutOnFlyFoulBall returns BatterMustOutOnFlyFoulBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter error=MUST_BE_OUT_ON_ERROR)
	 * </pre>
	 */
	protected void sequence_BatterMustOutOnFlyFoulBall(ISerializationContext context, BatterMustOutOnFlyFoulBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_MUST_OUT_ON_FLY_FOUL_BALL__ERROR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_MUST_OUT_ON_FLY_FOUL_BALL__ERROR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBatterMustOutOnFlyFoulBallAccess().getCurrentBatterCurrentBatterParserRuleCall_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getBatterMustOutOnFlyFoulBallAccess().getErrorMUST_BE_OUT_ON_ERRORTerminalRuleCall_3_0(), semanticObject.getError());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutByRule
	 *     BatterOut returns BatterOutByRule
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=OUT_BY_RULE notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutByRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnAppeal
	 *     BatterOut returns BatterOutOnAppeal
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=APPEAL notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnAppeal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnFlyed
	 *     BatterOut returns BatterOutOnFlyed
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=FLYED_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnFlyed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnFlyedFallBall
	 *     BatterOut returns BatterOutOnFlyedFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=FLYED_FALLBALL_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnFlyedFallBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnGroundedBall
	 *     BatterOut returns BatterOutOnGroundedBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=INT isBunt?='b'? notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnGroundedBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnGroundedDoublePlay
	 *     BatterOut returns BatterOutOnGroundedDoublePlay
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=GROUNDED_DOUBLE_PLAY_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnGroundedDoublePlay semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnInfieldFly
	 *     BatterOut returns BatterOutOnInfieldFly
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=INFIELD_FLY notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnInfieldFly semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnLine
	 *     BatterOut returns BatterOutOnLine
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=LINE_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnLineDriveFallBall
	 *     BatterOut returns BatterOutOnLineDriveFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=LINE_FALLBALL_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnLineDriveFallBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnPopped
	 *     BatterOut returns BatterOutOnPopped
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=POPPED_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnPopped semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnPoppedFallBall
	 *     BatterOut returns BatterOutOnPoppedFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=POPPED_FALLBALL_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnPoppedFallBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnSacrificeFly
	 *     BatterOut returns BatterOutOnSacrificeFly
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=SACRIFICE_FLY notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnSacrificeFly semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnSacrificeFlyFallBall
	 *     BatterOut returns BatterOutOnSacrificeFlyFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=SACRIFICE_FLY_FOUL_BALL notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnSacrificeFlyFallBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnSacrificeHit
	 *     BatterOut returns BatterOutOnSacrificeHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=SACRIFICE_BUNT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_FielderOut(ISerializationContext context, BatterOutOnSacrificeHit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnLookedStrike
	 *     BatterOut returns BatterOutOnLookedStrike
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter strikeOutValue=LOOKED_STRIKE_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_StrikeOut(ISerializationContext context, BatterOutOnLookedStrike semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnReleasedStrike
	 *     BatterOut returns BatterOutOnReleasedStrike
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter strikeOutValue=RELEASED_STRIKE_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_StrikeOut(ISerializationContext context, BatterOutOnReleasedStrike semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BatterAction returns BatterOutOnSwingedStrike
	 *     BatterOut returns BatterOutOnSwingedStrike
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter strikeOutValue=SWING_STRIKE_OUT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_BatterOut_StrikeOut(ISerializationContext context, BatterOutOnSwingedStrike semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Commands returns Commands
	 *
	 * Constraint:
	 *     (command=MoveCommand | command=SelectedBatterCommand)
	 * </pre>
	 */
	protected void sequence_Commands(ISerializationContext context, Commands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CurrentBatter returns CurrentBatter
	 *
	 * Constraint:
	 *     (batter=BATTER name=STRING?)
	 * </pre>
	 */
	protected void sequence_CurrentBatter(ISerializationContext context, CurrentBatter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CurrentRunner returns CurrentRunner
	 *
	 * Constraint:
	 *     (runner=RUNNER name=STRING?)
	 * </pre>
	 */
	protected void sequence_CurrentRunner(ISerializationContext context, CurrentRunner semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DecisiveError returns BatterAdvanceOnFlyError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=REACH_ON_FLY_ERROR)
	 * </pre>
	 */
	protected void sequence_DecisiveError(ISerializationContext context, BatterAdvanceOnFlyError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getCurrentBatterCurrentBatterParserRuleCall_0_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getBatterAdvanceREACH_ON_FLY_ERRORTerminalRuleCall_0_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DecisiveError returns BatterAdvanceOnGdpWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=GROUNDED_DOUBLE_PLAY_ADVANCE_WITH_ERROR)
	 * </pre>
	 */
	protected void sequence_DecisiveError(ISerializationContext context, BatterAdvanceOnGdpWithError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getCurrentBatterCurrentBatterParserRuleCall_3_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getBatterAdvanceGROUNDED_DOUBLE_PLAY_ADVANCE_WITH_ERRORTerminalRuleCall_3_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DecisiveError returns BatterAdvanceOnReceiveError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=REACH_ON_RECEIVE_ERROR)
	 * </pre>
	 */
	protected void sequence_DecisiveError(ISerializationContext context, BatterAdvanceOnReceiveError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getCurrentBatterCurrentBatterParserRuleCall_1_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getBatterAdvanceREACH_ON_RECEIVE_ERRORTerminalRuleCall_1_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DecisiveError returns BatterAdvanceOnThrowError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=REACH_ON_THROW_ERROR)
	 * </pre>
	 */
	protected void sequence_DecisiveError(ISerializationContext context, BatterAdvanceOnThrowError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.DECISIVE_ERROR__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getCurrentBatterCurrentBatterParserRuleCall_2_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getDecisiveErrorAccess().getBatterAdvanceREACH_ON_THROW_ERRORTerminalRuleCall_2_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefensiveChoiceForBatter returns BatterAdvanceOnDefensiveChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=FIELDER_CHOICE)
	 * </pre>
	 */
	protected void sequence_DefensiveChoiceForBatter(ISerializationContext context, BatterAdvanceOnDefensiveChoice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.DEFENSIVE_CHOICE_FOR_BATTER__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.DEFENSIVE_CHOICE_FOR_BATTER__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefensiveChoiceForBatterAccess().getCurrentBatterCurrentBatterParserRuleCall_1_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getDefensiveChoiceForBatterAccess().getBatterAdvanceFIELDER_CHOICETerminalRuleCall_1_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefensiveChoiceForBatter returns BatterAdvanceOnIndiference
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=INDIFERENCE)
	 * </pre>
	 */
	protected void sequence_DefensiveChoiceForBatter(ISerializationContext context, BatterAdvanceOnIndiference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.DEFENSIVE_CHOICE_FOR_BATTER__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.DEFENSIVE_CHOICE_FOR_BATTER__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefensiveChoiceForBatterAccess().getCurrentBatterCurrentBatterParserRuleCall_2_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getDefensiveChoiceForBatterAccess().getBatterAdvanceINDIFERENCETerminalRuleCall_2_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefensiveChoiceForBatter returns BatterAdvanceOnOccupedBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=FIELDER_CHOICE_WITH_PUTOUT)
	 * </pre>
	 */
	protected void sequence_DefensiveChoiceForBatter(ISerializationContext context, BatterAdvanceOnOccupedBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.DEFENSIVE_CHOICE_FOR_BATTER__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.DEFENSIVE_CHOICE_FOR_BATTER__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefensiveChoiceForBatterAccess().getCurrentBatterCurrentBatterParserRuleCall_0_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getDefensiveChoiceForBatterAccess().getBatterAdvanceFIELDER_CHOICE_WITH_PUTOUTTerminalRuleCall_0_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Description returns Description
	 *
	 * Constraint:
	 *     (
	 *         tournament=STRING | 
	 *         stadium=STRING | 
	 *         place=STRING | 
	 *         date=STRING | 
	 *         startTime=STRING | 
	 *         endTime=STRING | 
	 *         duration=STRING | 
	 *         category=STRING | 
	 *         type=GameTypeEnum | 
	 *         umpires=Umpires | 
	 *         scorekeepers=ScoreKeepers | 
	 *         notes=Notes
	 *     )+
	 * </pre>
	 */
	protected void sequence_Description(ISerializationContext context, Description semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutByRule
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=OUT_BY_RULE)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutByRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_BY_RULE__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_BY_RULE__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_7_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutOUT_BY_RULETerminalRuleCall_7_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnAppeal
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=APPEAL)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnAppeal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_APPEAL__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_APPEAL__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_8_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutAPPEALTerminalRuleCall_8_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnFlyed
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=FLYED_OUT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnFlyed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_FLYED__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_FLYED__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_0_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutFLYED_OUTTerminalRuleCall_0_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnFlyedFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=FLYED_FALLBALL_OUT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnFlyedFallBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_FLYED_FALL_BALL__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_FLYED_FALL_BALL__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_3_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutFLYED_FALLBALL_OUTTerminalRuleCall_3_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnGroundedBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=INT isBunt?='b'?)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnGroundedBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnGroundedDoublePlay
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=GROUNDED_DOUBLE_PLAY_OUT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnGroundedDoublePlay semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_GROUNDED_DOUBLE_PLAY__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_GROUNDED_DOUBLE_PLAY__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_9_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutGROUNDED_DOUBLE_PLAY_OUTTerminalRuleCall_9_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnInfieldFly
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=INFIELD_FLY)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnInfieldFly semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_INFIELD_FLY__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_INFIELD_FLY__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_13_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutINFIELD_FLYTerminalRuleCall_13_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnLine
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=LINE_OUT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_LINE__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_LINE__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_1_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutLINE_OUTTerminalRuleCall_1_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnLineDriveFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=LINE_FALLBALL_OUT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnLineDriveFallBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_LINE_DRIVE_FALL_BALL__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_LINE_DRIVE_FALL_BALL__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_5_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutLINE_FALLBALL_OUTTerminalRuleCall_5_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnPopped
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=POPPED_OUT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnPopped semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_POPPED__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_POPPED__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_2_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutPOPPED_OUTTerminalRuleCall_2_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnPoppedFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=POPPED_FALLBALL_OUT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnPoppedFallBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_POPPED_FALL_BALL__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_POPPED_FALL_BALL__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_4_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutPOPPED_FALLBALL_OUTTerminalRuleCall_4_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnSacrificeFly
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=SACRIFICE_FLY)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnSacrificeFly semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_SACRIFICE_FLY__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_SACRIFICE_FLY__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_10_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutSACRIFICE_FLYTerminalRuleCall_10_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnSacrificeFlyFallBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=SACRIFICE_FLY_FOUL_BALL)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnSacrificeFlyFallBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_SACRIFICE_FLY_FALL_BALL__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_SACRIFICE_FLY_FALL_BALL__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_11_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutSACRIFICE_FLY_FOUL_BALLTerminalRuleCall_11_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FielderOut returns BatterOutOnSacrificeHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterOut=SACRIFICE_BUNT)
	 * </pre>
	 */
	protected void sequence_FielderOut(ISerializationContext context, BatterOutOnSacrificeHit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_OUT_ON_SACRIFICE_HIT__BATTER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_OUT_ON_SACRIFICE_HIT__BATTER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFielderOutAccess().getCurrentBatterCurrentBatterParserRuleCall_12_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getFielderOutAccess().getBatterOutSACRIFICE_BUNTTerminalRuleCall_12_3_0(), semanticObject.getBatterOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ForfeitGame returns ForfeitGame
	 *
	 * Constraint:
	 *     team=TeamTypeEnum
	 * </pre>
	 */
	protected void sequence_ForfeitGame(ISerializationContext context, ForfeitGame semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.FORFEIT_GAME__TEAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.FORFEIT_GAME__TEAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForfeitGameAccess().getTeamTeamTypeEnumParserRuleCall_1_0(), semanticObject.getTeam());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GameResume returns GameResume
	 *
	 * Constraint:
	 *     (win=STRING lose=STRING save=STRING?)
	 * </pre>
	 */
	protected void sequence_GameResume(ISerializationContext context, GameResume semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     (name=STRING description=Description visitor=Roster hometeam=Roster (forfeitGame=ForfeitGame | actions=Actions))
	 * </pre>
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HalfInning returns HalfInning
	 *
	 * Constraint:
	 *     (
	 *         team=TeamTypeEnum 
	 *         number=INT 
	 *         inningSetting+=InningSetting* 
	 *         (inningElements+=SubstitutionEvent | inningElements+=Action | inningElements+=Commands | notes+=Note)*
	 *     )
	 * </pre>
	 */
	protected void sequence_HalfInning(ISerializationContext context, HalfInning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Hit returns BatterAdvanceOnDoubleHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=DOUBLE)
	 * </pre>
	 */
	protected void sequence_Hit(ISerializationContext context, BatterAdvanceOnDoubleHit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.HIT__HIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.HIT__HIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHitAccess().getCurrentBatterCurrentBatterParserRuleCall_1_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getHitAccess().getHitDOUBLETerminalRuleCall_1_3_0(), semanticObject.getHit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Hit returns BatterAdvanceOnHomeRun
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=HOMERUN (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_Hit(ISerializationContext context, BatterAdvanceOnHomeRun semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Hit returns BatterAdvanceOnInsidePark
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=INSIDE_PARK (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_Hit(ISerializationContext context, BatterAdvanceOnInsidePark semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Hit returns BatterAdvanceOnSingleHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=SINGLE)
	 * </pre>
	 */
	protected void sequence_Hit(ISerializationContext context, BatterAdvanceOnSingleHit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.HIT__HIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.HIT__HIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHitAccess().getCurrentBatterCurrentBatterParserRuleCall_0_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getHitAccess().getHitSINGLETerminalRuleCall_0_3_0(), semanticObject.getHit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Hit returns BatterAdvanceOnTripleHit
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter hit=TRIPLE)
	 * </pre>
	 */
	protected void sequence_Hit(ISerializationContext context, BatterAdvanceOnTripleHit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.HIT__HIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.HIT__HIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHitAccess().getCurrentBatterCurrentBatterParserRuleCall_2_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getHitAccess().getHitTRIPLETerminalRuleCall_2_3_0(), semanticObject.getHit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InningSetting returns InningSetting
	 *
	 * Constraint:
	 *     isTiebrak?='tieBreak'?
	 * </pre>
	 */
	protected void sequence_InningSetting(ISerializationContext context, InningSetting semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LineUpEntry returns LineUpEntry
	 *
	 * Constraint:
	 *     (name=STRING defensivePosition=LineUPAtDefensivePosition shirtNumber=INT? laterality=LATERALITY?)
	 * </pre>
	 */
	protected void sequence_LineUpEntry(ISerializationContext context, LineUpEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LineUp returns LineUp
	 *
	 * Constraint:
	 *     (teamType=TeamTypeEnum lineUpEntries+=LineUpEntry+)
	 * </pre>
	 */
	protected void sequence_LineUp(ISerializationContext context, LineUp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MoreAdanceFail returns RunnerOutByRules
	 *
	 * Constraint:
	 *     runnerOut=OUT_BY_RULE
	 * </pre>
	 */
	protected void sequence_MoreAdanceFail(ISerializationContext context, RunnerOutByRules semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_OUT_BY_RULES__RUNNER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_OUT_BY_RULES__RUNNER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoreAdanceFailAccess().getRunnerOutOUT_BY_RULETerminalRuleCall_1_1_0(), semanticObject.getRunnerOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MoreAdanceFail returns RunnerOutOnAppeal
	 *
	 * Constraint:
	 *     runnerOut=APPEAL
	 * </pre>
	 */
	protected void sequence_MoreAdanceFail(ISerializationContext context, RunnerOutOnAppeal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_OUT_ON_APPEAL__RUNNER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_OUT_ON_APPEAL__RUNNER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoreAdanceFailAccess().getRunnerOutAPPEALTerminalRuleCall_2_1_0(), semanticObject.getRunnerOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MoreAdanceFail returns RunnerOutOnFielderAction
	 *
	 * Constraint:
	 *     runnerOut=INT
	 * </pre>
	 */
	protected void sequence_MoreAdanceFail(ISerializationContext context, RunnerOutOnFielderAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_OUT_ON_FIELDER_ACTION__RUNNER_OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_OUT_ON_FIELDER_ACTION__RUNNER_OUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoreAdanceFailAccess().getRunnerOutINTTerminalRuleCall_0_1_0(), semanticObject.getRunnerOut());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MoveCommand returns MoveCommand
	 *
	 * Constraint:
	 *     columnNumber=INT
	 * </pre>
	 */
	protected void sequence_MoveCommand(ISerializationContext context, MoveCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.MOVE_COMMAND__COLUMN_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.MOVE_COMMAND__COLUMN_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveCommandAccess().getColumnNumberINTTerminalRuleCall_2_0(), semanticObject.getColumnNumber());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NewDefensivePosition returns NewDefensivePosition
	 *
	 * Constraint:
	 *     (newDefensivePosition=LineUPAtDefensivePosition laterality=LATERALITY?)
	 * </pre>
	 */
	protected void sequence_NewDefensivePosition(ISerializationContext context, NewDefensivePosition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Note returns Note
	 *
	 * Constraint:
	 *     notes=STRING
	 * </pre>
	 */
	protected void sequence_Note(ISerializationContext context, Note semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.NOTE__NOTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.NOTE__NOTES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNoteAccess().getNotesSTRINGTerminalRuleCall_2_0(), semanticObject.getNotes());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Notes returns Notes
	 *
	 * Constraint:
	 *     (notes+=STRING notess+=STRING*)
	 * </pre>
	 */
	protected void sequence_Notes(ISerializationContext context, Notes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnBaseOnBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=BASE_ON_BALL)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnBaseOnBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_0_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceBASE_ON_BALLTerminalRuleCall_0_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnCatcherInterference
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter (batterAdvance=CATCHER_INTERFERENCE | batterAdvance=INTERFERENCE))
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnCatcherInterference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnGdpWithFielderChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=GROUNDED_DOUBLE_PLAY_ADVANCE_WITH_FIELDER_CHOICE)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnGdpWithFielderChoice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_14_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceGROUNDED_DOUBLE_PLAY_ADVANCE_WITH_FIELDER_CHOICETerminalRuleCall_14_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnHitByPitch
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=HIT_BY_PITCH)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnHitByPitch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_2_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceHIT_BY_PITCHTerminalRuleCall_2_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnIntentionalBaseOnBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=INTENTIONAL_BASE_ON_BALL)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnIntentionalBaseOnBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_1_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceINTENTIONAL_BASE_ON_BALLTerminalRuleCall_1_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnKAbr
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_ADVANCE_BY_RULE)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKAbr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_5_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceK_ADVANCE_BY_RULETerminalRuleCall_5_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnKPassBall
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_PASS_BALL)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKPassBall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_3_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceK_PASS_BALLTerminalRuleCall_3_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnKWildPitch
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_WILD_PITCH)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKWildPitch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_4_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceK_WILD_PITCHTerminalRuleCall_4_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnKWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_WITH_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKWithError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_6_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceK_WITH_ERRORTerminalRuleCall_6_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnKWithFielderChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=K_ADVANCE_BY_FIELDER_CHOCE)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnKWithFielderChoice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_13_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceK_ADVANCE_BY_FIELDER_CHOCETerminalRuleCall_13_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnObstruction
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=DECISIVE_OBSTRUCTION)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnObstruction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_12_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceDECISIVE_OBSTRUCTIONTerminalRuleCall_12_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnSacrificeFlyWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_FLY_WITH_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeFlyWithError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_9_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceSACRIFICE_FLY_WITH_ERRORTerminalRuleCall_9_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnSacrificeFlyWithFielderChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_FLY_WITH_FIELDER_CHOICE)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeFlyWithFielderChoice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_10_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceSACRIFICE_FLY_WITH_FIELDER_CHOICETerminalRuleCall_10_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnSacrificeHitWithError
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_BUNT_WITH_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeHitWithError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_7_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceSACRIFICE_BUNT_WITH_ERRORTerminalRuleCall_7_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OtherBatterAdvance returns BatterAdvanceOnSacrificeHitWithFielderChoice
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter batterAdvance=SACRIFICE_BUNT_WITH_FIELDER_CHOICE)
	 * </pre>
	 */
	protected void sequence_OtherBatterAdvance(ISerializationContext context, BatterAdvanceOnSacrificeHitWithFielderChoice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_BATTER_ADVANCE__BATTER_ADVANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getCurrentBatterCurrentBatterParserRuleCall_8_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getOtherBatterAdvanceAccess().getBatterAdvanceSACRIFICE_BUNT_WITH_FIELDER_CHOICETerminalRuleCall_8_3_0(), semanticObject.getBatterAdvance());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerDontAdvanceOnCaughtStealingWithError
	 *     OtherRunnerAction returns RunnerDontAdvanceOnCaughtStealingWithError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=CAUGTH_STEALING_WITH_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerDontAdvanceOnCaughtStealingWithError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_3_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodeCAUGTH_STEALING_WITH_ERRORTerminalRuleCall_2_3_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerDontAdvanceOnError
	 *     OtherRunnerAction returns RunnerDontAdvanceOnError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=ADVANCE_ON_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerDontAdvanceOnError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_1_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodeADVANCE_ON_ERRORTerminalRuleCall_2_1_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerDontAdvanceOnNonDecisiveReceiveError
	 *     OtherRunnerAction returns RunnerDontAdvanceOnNonDecisiveReceiveError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=EXTRA_ON_RECEIVE_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerDontAdvanceOnNonDecisiveReceiveError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_7_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodeEXTRA_ON_RECEIVE_ERRORTerminalRuleCall_2_7_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerDontAdvanceOnNonDecisiveThrowError
	 *     OtherRunnerAction returns RunnerDontAdvanceOnNonDecisiveThrowError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=EXTRA_ON_THROW_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerDontAdvanceOnNonDecisiveThrowError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_6_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodeEXTRA_ON_THROW_ERRORTerminalRuleCall_2_6_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerDontAdvanceOnPickOffWithError
	 *     OtherRunnerAction returns RunnerDontAdvanceOnPickOffWithError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=PICK_OFF_WITH_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerDontAdvanceOnPickOffWithError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_2_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodePICK_OFF_WITH_ERRORTerminalRuleCall_2_2_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerDontAdvanceOnReceiveError
	 *     OtherRunnerAction returns RunnerDontAdvanceOnReceiveError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=REACH_ON_RECEIVE_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerDontAdvanceOnReceiveError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_5_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodeREACH_ON_RECEIVE_ERRORTerminalRuleCall_2_5_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerDontAdvanceOnThrowError
	 *     OtherRunnerAction returns RunnerDontAdvanceOnThrowError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=REACH_ON_THROW_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerDontAdvanceOnThrowError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_4_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodeREACH_ON_THROW_ERRORTerminalRuleCall_2_4_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerMustBeOutOnError
	 *     OtherRunnerAction returns RunnerMustBeOutOnError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner actionCode=MUST_BE_OUT_ON_ERROR)
	 * </pre>
	 */
	protected void sequence_OtherRunnerAction(ISerializationContext context, RunnerMustBeOutOnError semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.RUNNER_ACTION__RUNNER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.OTHER_RUNNER_ACTION__ACTION_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getRunnerCurrentRunnerParserRuleCall_2_0_1_0(), semanticObject.getRunner());
		feeder.accept(grammarAccess.getOtherRunnerActionAccess().getActionCodeMUST_BE_OUT_ON_ERRORTerminalRuleCall_2_0_3_0(), semanticObject.getActionCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pitch returns Pitch
	 *
	 * Constraint:
	 *     pitch=TypeOfPitch
	 * </pre>
	 */
	protected void sequence_Pitch(ISerializationContext context, Pitch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.PITCH__PITCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.PITCH__PITCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPitchAccess().getPitchTypeOfPitchParserRuleCall_0(), semanticObject.getPitch());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pitches returns Pitches
	 *
	 * Constraint:
	 *     (pitches+=Pitch pitches+=Pitch*)
	 * </pre>
	 */
	protected void sequence_Pitches(ISerializationContext context, Pitches semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Player returns Player
	 *
	 * Constraint:
	 *     playerName=STRING
	 * </pre>
	 */
	protected void sequence_Player(ISerializationContext context, Player semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.PLAYER__PLAYER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.PLAYER__PLAYER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlayerAccess().getPlayerNameSTRINGTerminalRuleCall_1_0(), semanticObject.getPlayerName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Replacement returns Replacement
	 *
	 * Constraint:
	 *     (((name=STRING shirtNumber=INT?) | defensivePosition=INT) newDefensivePosition=LineUPAtDefensivePosition? laterality=LATERALITY?)
	 * </pre>
	 */
	protected void sequence_Replacement(ISerializationContext context, Replacement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Roster returns Roster
	 *
	 * Constraint:
	 *     (who=TeamTypeEnum name=STRING (players+=Player players+=Player*)?)
	 * </pre>
	 */
	protected void sequence_Roster(ISerializationContext context, Roster semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceByBatterAction
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=ADVANCE 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceByBatterAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnBalk
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=BALK 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnBalk semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnCaughtStealingWithError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=CAUGTH_STEALING_WITH_ERROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnCaughtStealingWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnDecisiveObstruction
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=DECISIVE_OBSTRUCTION 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnDecisiveObstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=ADVANCE_ON_ERROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnFielderChoice
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=FIELDER_CHOICE 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnFielderChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnIndiference
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=INDIFERENCE 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnIndiference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnNoDecisiveObstruction
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=NO_DECISIVE_OBSTRUCTION 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnNoDecisiveObstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnNonDecisiveReceiveError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=EXTRA_ON_RECEIVE_ERROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnNonDecisiveReceiveError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnNonDecisiveThrowError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=EXTRA_ON_THROW_ERROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnNonDecisiveThrowError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnOccupedBall
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=FIELDER_CHOICE_WITH_PUTOUT 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnOccupedBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnOtherPlayerError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=ADVANCE_BY_OTHER_PLAYER_EROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnOtherPlayerError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnPassBall
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=PASS_BALL 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnPassBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnPickOffWithError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=PICK_OFF_WITH_ERROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnPickOffWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnReceiveError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=REACH_ON_RECEIVE_ERROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnReceiveError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnRule
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=ADVANCE_BY_RULE 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnStolenBase
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=STOLEN_BASE 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnStolenBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnThrow
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=ADVANCE_ON_THROW 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnThrow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnThrowError
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=REACH_ON_THROW_ERROR 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnThrowError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerAdvanceOnWildPitch
	 *
	 * Constraint:
	 *     (
	 *         runner=CurrentRunner 
	 *         runnerAdvance=WILD_PITCH 
	 *         (isEarned='earned' | isEarned='unEarnedForTeam')? 
	 *         moreAdvances+=AdvanceWithContinuation* 
	 *         runnerOut=MoreAdanceFail?
	 *     )
	 * </pre>
	 */
	protected void sequence_RunnerAction_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnWildPitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceByBatterAction
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=ADVANCE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceByBatterAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnBalk
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=BALK (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnBalk semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnCaughtStealingWithError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=CAUGTH_STEALING_WITH_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnCaughtStealingWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnDecisiveObstruction
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=DECISIVE_OBSTRUCTION (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnDecisiveObstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=ADVANCE_ON_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnFielderChoice
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=FIELDER_CHOICE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnFielderChoice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnIndiference
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=INDIFERENCE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnIndiference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnNoDecisiveObstruction
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=NO_DECISIVE_OBSTRUCTION (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnNoDecisiveObstruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnNonDecisiveReceiveError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=EXTRA_ON_RECEIVE_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnNonDecisiveReceiveError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnNonDecisiveThrowError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=EXTRA_ON_THROW_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnNonDecisiveThrowError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnOccupedBall
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=FIELDER_CHOICE_WITH_PUTOUT (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnOccupedBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnOtherPlayerError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=ADVANCE_BY_OTHER_PLAYER_EROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnOtherPlayerError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnPassBall
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=PASS_BALL (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnPassBall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnPickOffWithError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=PICK_OFF_WITH_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnPickOffWithError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnReceiveError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=REACH_ON_RECEIVE_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnReceiveError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnRule
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=ADVANCE_BY_RULE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnStolenBase
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=STOLEN_BASE (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnStolenBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnThrow
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=ADVANCE_ON_THROW (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnThrow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnThrowError
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=REACH_ON_THROW_ERROR (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnThrowError semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAdvance returns RunnerAdvanceOnWildPitch
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerAdvance=WILD_PITCH (isEarned='earned' | isEarned='unEarnedForTeam')?)
	 * </pre>
	 */
	protected void sequence_RunnerAdvance(ISerializationContext context, RunnerAdvanceOnWildPitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerOutByRules
	 *     RunnerOut returns RunnerOutByRules
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerOut=OUT_BY_RULE notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_RunnerOut(ISerializationContext context, RunnerOutByRules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerOutOnAppeal
	 *     RunnerOut returns RunnerOutOnAppeal
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerOut=APPEAL notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_RunnerOut(ISerializationContext context, RunnerOutOnAppeal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerOutOnCaugthStealing
	 *     RunnerOut returns RunnerOutOnCaugthStealing
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerOut=CAUGTH_STEALING notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_RunnerOut(ISerializationContext context, RunnerOutOnCaugthStealing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerOutOnFielderAction
	 *     RunnerOut returns RunnerOutOnFielderAction
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerOut=INT notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_RunnerOut(ISerializationContext context, RunnerOutOnFielderAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunnerAction returns RunnerOutOnPickOff
	 *     RunnerOut returns RunnerOutOnPickOff
	 *
	 * Constraint:
	 *     (runner=CurrentRunner runnerOut=PICK_OFF notInDoublePlay?='dontCountAsDoublePlay'?)
	 * </pre>
	 */
	protected void sequence_RunnerOut(ISerializationContext context, RunnerOutOnPickOff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScoreKeepers returns ScoreKeepers
	 *
	 * Constraint:
	 *     (scorekeepers+=STRING scorekeepers+=STRING*)
	 * </pre>
	 */
	protected void sequence_ScoreKeepers(ISerializationContext context, ScoreKeepers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectedBatterCommand returns SelectedBatterCommand
	 *
	 * Constraint:
	 *     starterBatter=INT
	 * </pre>
	 */
	protected void sequence_SelectedBatterCommand(ISerializationContext context, SelectedBatterCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.SELECTED_BATTER_COMMAND__STARTER_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.SELECTED_BATTER_COMMAND__STARTER_BATTER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectedBatterCommandAccess().getStarterBatterINTTerminalRuleCall_2_0(), semanticObject.getStarterBatter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StrikeOut returns BatterOutOnLookedStrike
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter strikeOutValue=LOOKED_STRIKE_OUT)
	 * </pre>
	 */
	protected void sequence_StrikeOut(ISerializationContext context, BatterOutOnLookedStrike semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.STRIKE_OUT__STRIKE_OUT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.STRIKE_OUT__STRIKE_OUT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStrikeOutAccess().getCurrentBatterCurrentBatterParserRuleCall_1_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getStrikeOutAccess().getStrikeOutValueLOOKED_STRIKE_OUTTerminalRuleCall_1_3_0(), semanticObject.getStrikeOutValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StrikeOut returns BatterOutOnReleasedStrike
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter strikeOutValue=RELEASED_STRIKE_OUT)
	 * </pre>
	 */
	protected void sequence_StrikeOut(ISerializationContext context, BatterOutOnReleasedStrike semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.STRIKE_OUT__STRIKE_OUT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.STRIKE_OUT__STRIKE_OUT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStrikeOutAccess().getCurrentBatterCurrentBatterParserRuleCall_2_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getStrikeOutAccess().getStrikeOutValueRELEASED_STRIKE_OUTTerminalRuleCall_2_3_0(), semanticObject.getStrikeOutValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StrikeOut returns BatterOutOnSwingedStrike
	 *
	 * Constraint:
	 *     (currentBatter=CurrentBatter strikeOutValue=SWING_STRIKE_OUT)
	 * </pre>
	 */
	protected void sequence_StrikeOut(ISerializationContext context, BatterOutOnSwingedStrike semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.BATTER_ACTION__CURRENT_BATTER));
			if (transientValues.isValueTransient(semanticObject, GamePackage.Literals.STRIKE_OUT__STRIKE_OUT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GamePackage.Literals.STRIKE_OUT__STRIKE_OUT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStrikeOutAccess().getCurrentBatterCurrentBatterParserRuleCall_0_1_0(), semanticObject.getCurrentBatter());
		feeder.accept(grammarAccess.getStrikeOutAccess().getStrikeOutValueSWING_STRIKE_OUTTerminalRuleCall_0_3_0(), semanticObject.getStrikeOutValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubstitutionDescription returns SubstitutionDescription
	 *
	 * Constraint:
	 *     (currentDefensivePosition=LineUPCurrentDefensivePosition name=STRING? (subtitution=Replacement | subtitution=NewDefensivePosition))
	 * </pre>
	 */
	protected void sequence_SubstitutionDescription(ISerializationContext context, SubstitutionDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubstitutionEvent returns SubstitutionEvent
	 *
	 * Constraint:
	 *     ((team=TeamTypeEnum substitutions+=SubstitutionDescription substitutions+=SubstitutionDescription*) | substitutions+=SubstitutionDescription)
	 * </pre>
	 */
	protected void sequence_SubstitutionEvent(ISerializationContext context, SubstitutionEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Umpires returns Umpires
	 *
	 * Constraint:
	 *     (umpires+=STRING umpires+=STRING*)
	 * </pre>
	 */
	protected void sequence_Umpires(ISerializationContext context, Umpires semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
