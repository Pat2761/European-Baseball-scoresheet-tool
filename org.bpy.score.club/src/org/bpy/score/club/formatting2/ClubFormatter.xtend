/*
 * European scorekeeper tool
 * Copyright (C) 2020  Patrick BRIAND
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * generated by Xtext 2.23.0
 *
 */
package org.bpy.score.club.formatting2

import org.bpy.score.club.club.Club
import org.bpy.score.club.club.ClubDescription
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.bpy.score.club.club.ClubPackage
import org.bpy.score.club.club.Members
import org.bpy.score.club.club.Member
import org.bpy.score.club.club.Team
import org.bpy.score.club.club.Player
import org.bpy.score.club.club.Officials
import org.bpy.score.club.club.Official
import org.bpy.score.club.club.MemberStatus

/**
 * Allow to format a club file
 * 
 * @author: Patrick BRIAND
 */
class ClubFormatter extends AbstractFormatter2 {
	
	/**
	 * Format the entry point of the club file.
	 * 
	 */
	def dispatch void format(Club club, extension IFormattableDocument document) {
		club.regionFor.feature(ClubPackage.Literals.CLUB__NAME).prepend[oneSpace]
		club.regionFor.feature(ClubPackage.Literals.CLUB__NAME).append[oneSpace]
		club.regionFor.keyword("{").append[newLine;indent]

		val open = club.regionFor.keyword("{")
		val close = club.regionFor.keyword("}")
		if (open !== null && close !== null) {
			interior(open, close)[indent]
		club.clubDescription.format
		}		
		
	}

	/**
	 * Format the description of the of the club  
 	 */
	def dispatch void format(ClubDescription clubDescription, extension IFormattableDocument document) {
		clubDescription.regionFor.keyword("=").prepend[noSpace].append[noSpace]
		clubDescription.regionFor.keyword(";").prepend[noSpace].append[newLines = 2]
		clubDescription.members.format
		clubDescription.teams.forEach[format]
		clubDescription.officials.format
		
	}
	
	/**
	 * Format the description of the members bloc
	 * 
	 */
	def dispatch void format(Members members, extension IFormattableDocument document) {
		
		val open = members.regionFor.keyword("{")
		open.append[newLine]
		val close = members.regionFor.keyword("}")
		if (open !== null && close !== null) {
			interior(open, close)[indent]
			members.members.forEach[format]
		}
		close.append[newLines = 2]
	}
	
	/**
	 * Format the description of a member
	 * 
	 */
	def dispatch void format(Member member, extension IFormattableDocument document) {
		member.regionFor.keyword("member").prepend[indent;indent].append[oneSpace]

		member.regionFor.keyword("name").append[noSpace]
		member.regionFor.feature(ClubPackage.Literals.MEMBER__NAME).prepend[noSpace].append[oneSpace]

		member.regionFor.keyword("shortName").prepend[oneSpace].append[noSpace]
		member.regionFor.feature(ClubPackage.Literals.MEMBER__SHORT_NAME).prepend[noSpace]
		
		member.regionFor.keyword("licenceNumber").prepend[oneSpace].append[noSpace].append[noAutowrap]
		member.regionFor.feature(ClubPackage.Literals.MEMBER__LICENCE_NUMBER).prepend[noSpace]

		member.regionFor.keyword("shirtNumber").prepend[oneSpace].append[noSpace]
		member.regionFor.feature(ClubPackage.Literals.MEMBER__SHIRT_NUMBER).prepend[noSpace]
		
		member.regionFor.keyword("status").prepend[oneSpace].append[noSpace]

		member.status.format

		member.regionFor.keyword(";").prepend[noSpace].append[newLine]
	}
	
	/**
	 * Format the status of a member
	 * Remove spaces between each attribute
	 * remove space at the beginning of the state and at the end of the state
	 * 
	 * 
	 */
	def dispatch void format(MemberStatus status, extension IFormattableDocument document) {
		val regions = status.regionFor.keywords(",")
		
		if (regions.length>0) {
			for (comma : status.regionFor.keywords(",")) {
				comma.prepend[noSpace].append[noSpace]
			}
		} else {
			status.prepend[noSpace].append[noSpace]
		}	
	}
	
	/**
	 * Format a team an invoke the the format of the each player in a team
	 * 
	 */
	def dispatch void format(Team team, extension IFormattableDocument document) {
		team.regionFor.feature(ClubPackage.Literals.TEAM__NAME).prepend[oneSpace].append[oneSpace]
		team.regionFor.keyword("{").append[newLine]		
		
		val open = team.regionFor.keyword("{")
		open.append[newLine]
		val close = team.regionFor.keyword("}")
		if (open !== null && close !== null) {
			interior(open, close)[indent]
			team.players.forEach[format]
		}
		close.append[newLines = 2]
	}

	/**
	 * Format a player in a team
	 */
	def dispatch void format(Player player, extension IFormattableDocument document) {
		player.regionFor.keyword("=").prepend[noSpace].append[noSpace]
		player.regionFor.keyword(";").prepend[noSpace].append[newLine]
	}
	
	/**
	 * Format the officials blocs and invoke the the format of the each official
	 * 
	 */
	def dispatch void format(Officials officials, extension IFormattableDocument document) {
		officials.regionFor.keyword("{").prepend[oneSpace].append[newLine]
		val open = officials.regionFor.keyword("{")
		open.append[newLine]
		val close = officials.regionFor.keyword("}")
		if (open !== null && close !== null) {
			interior(open, close)[indent]
			officials.officials.forEach[format]
		}
	}

	def dispatch void format(Official official, extension IFormattableDocument document) {
		official.regionFor.keyword("name").prepend[oneSpace].append[noSpace]
		official.regionFor.keyword("=").append[noSpace]
		official.regionFor.keyword(";").prepend[noSpace].append[newLine]
	}
}
